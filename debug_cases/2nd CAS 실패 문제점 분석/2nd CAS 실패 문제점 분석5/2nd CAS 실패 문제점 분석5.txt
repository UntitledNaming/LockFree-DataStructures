1. 문제점 분석
- 지금 2nd CAS에서 무한 루프 도는 상황이 원인을 생각해보자. 지금 1번 스레드는 31555 루프 카운트가 있고 2번 스레드는 31663 루프 카운트를 가지는데 이때 다시 재개 해서 루프 카운트를 보자.
   재개하고 다시 멈추고 루프 카운터 보니 똑같음. 즉, 무한 루프에 빠졌음.
- 어디서 각자가 멈췄냐면 9188 스레드는 1st CAS 랑 2nd CAS사이에서 무한 루프 돌고 있고 15588 스레드는 1st CAS 통과 못하고 무한 루프 돌고 있음. 
- 1st CAS 통과 못하고 무한 루프 돌고 있는 스레드가 바라보는 tailnode는 0x2d70025dac871860임. 
- 1st CAS랑 2ndCAS 사이에서 무한루프 돌고 있는 스레드가 바라보는 tailNode 주소값은 0x2d70025dac871860이고 그 스레드가 2ndCAS를 할때 m_Tail로 바꾸려던 newNode 주소값이
   0x2d70025dac871860임. 즉, 바꾸고 나서 본인도 탈출 못하고 다른 스레드도 영향 받아서 1st CAS를 못하고 있음.

- 이 상황이 발생할수 있는 시나리오를 생각해보자. tailnode가 newnode로 바뀌었다는 것은 결국 2ndCAS를 성공했다는 것임. 먼저 1st CAS 성공한 스레드 tail 갱신하고(노드 4) 나중에 1st CAS 들어온 스레드도
   같은 tail노드 주소로 갱신함. 그리고 나서 먼저 1stCAS 성공한 스레드가 2ndCAS를 해서 m_pTail을 노드3(tag :5)로 바꾸는데 성공할 것이고 이때 1stCAS 나중에 성공한 스레드가 2ndCAS를 시도하는데
   m_pTail(노드 3)이랑 refreshTail(노드 4)이니 tailNode가 실제 큐 맨 끝으로 못가고 결국 모든 스레드가 무한 루프를 돌아버림.

- 다른 구조를 생각해보자.
   우선 다시 2ndCAS에서 경쟁이 생길 때와 아닐때를 구분해보자. 먼저 경쟁이 생기는 경우 ret값이랑 localTail을 비교할 때 먼저 1stCAS한 스레드는 ret값이랑 localTail이랑 같아서 먼저 1stCAS한 스레드가
   2ndCAS를 성공해도 그냥 Pass할 것이고 2ndCAS를 실패해도 그냥 Pass할 것임. 
- if (ret2ndCAS != localTail) 를 통과할 수 있는 상황을 생각해보자. 먼저 1stCAS한 스레드가 잠깐 멈춘사이 나중에 1stCAS한 스레드가 2ndCAS를 해버려서 tail을 진짜 바꾼 다음 먼저 1stCAS한 스레드가
   2ndCAS를 하면 ret값은 노드 5, local값은 노드 4임. 
- 다른 상황은 나중에 1stCAS한 스레드가 잠깐 멈춘사이 먼저 1stCAS한 스레드가 2ndCAS를 해서 m_Tail을 노드 3(tag: 5)로 바꾸고 나중에 1stCAS한 스레드가 2ndCAS를 하는데 이때 ret값이
   노드3(tag: 5)고 local값이 노드3(tag : 0)임. 
- 마지막 상황은 먼저 1stCAS한 스레드랑 나중에 1stCAS한 스레드가 2ndCAS에서 경합을 벌이는 상황임. 이때 먼저 1stCAS한 스레드가 경합에 실패하고 나중에 CAS한 스레드가 성공해도 경합 실패한
   스레드는 어차피 ret값이랑 local값이랑 같아서 어차피 pass할 것임. 반대로 먼저 1stCAS한 스레드가 경합에 성공하고 나중에 CAS한 스레드가 실패하는 경우 
   나중에 cas한 스레드가 측정한 ret값이 노드 4이고 local값이 노드 3(tag:0)임.
- 이 3가지 상황에서 단순히 if문으로 2ndCAS 실패 체크해서 내부로 들어갈 때 단순히 m_Tail을 내 newNode로 바꿔버리면 1가지 상황인 먼저 1stCAS 성공한 스레드가 나중에 cas한 스레드가 2ndCAS 성공후
   2ndCAS할 때 도 if문 내부로 들어올건데 이때 그냥 m_Tail을 내 newNode로 바꾸면 문제가 생길 것임. tail을 잘못 바꾸는 것임. 그러면 이때 이 상황을 체크할 수 있는 상황 1개가 일단 내부로 들어와서
   ret값에 tag를 때서 next가 nullptr이면 굳이 내부에서 m_Tail = newNode 할 필요없이 그냥 나가면 됨.

- 그러면 nullptr이 아닌 상황을 생각해보면 나중에 CAS한 스레드가 2ndCAS하고 먼저 1stCAS한 스레드가 2ndCAS에서 실패할 때 if문 분기타고 들어가서 리턴값 tag땔 때(노드 5) 그 순간 어쨌든 다른 스레드들이
   1stCAS를 할 수 있는 상황일 것임. 이때 그러면 tag때는 중에 1stCAS를 해버리면 tail->next는 nullptr이 안될 것임.
   그리고 먼저 1stCAS한 스레드가 2ndCAS까지 해서 m_tail을 노드 3(tag: 5)로 바꾸고 나서 나중에 cas한 스레드가 2ndCAS할 때 ret값이 노드 3(tag:5)가 나오고 local이 노드3(tag:0) 나오니 노드3(tag:5)를
   tag때도 next 보면 nullptr이 아님.
   다른 상황으로 나중에 cas한 스레드가 2ndCAS 경합에 실패해서 ret값이 노드 4가 나오고 local이 노드3(tag:0)인 상황에서 ret값 tag때고 next봐도 nullptr이 아님.
- 여기서 첫번째로 말한 상황으로 인해 nullptr이 아닐 수도 있어서 그때 그냥 m_Tail = newNode로 해버리면 큐가 꼬여버릴 것임.
- 그러면 이때 2ndCAS를 그대로 다시 진행하는 로직을 생각해보자. 그런데 ret값에서 tag땐 노드의 next가 nullptr이 아닐 때 m_Tail = newNode로도 못바꾸는데 다시 그냥 2ndCAS하면 달라지는게 있나?
   

==================================================================================================================================================================
- 아니면 애초에 실패할때가 아니라 성공할때 로직을 넣고 실패는 그냥 Pass해버리는 것임.
   어떤 상황에서 발생하냐면 
가. 진짜 먼저 1stCAS한 스레드가 나중에 CAS한 스레드가 2ndCAS전에 먼저 해버려서 성공하는 경우
나. 진짜 나중에 CAS한 스레드가 먼저 1stCAS한 스레드가 2ndCAS하기 전에 먼저 해버려서 성공하는 경우
다. 둘다 2ndCAS에서 경쟁해서 먼저 1stCAS한 스레드가 실패하고 나중에 CAS한 스레드가 성공하는 경우 먼저 1stCAS 한 스레드가 ret값 노드 4고 local도 노드 4라서 통과함.


- 그러면 성공한 쪽에서 실제 큐 맨 끝 노드 주소로 tail변수를 못바꾸는 상황이 '가'랑 '다'임. 이때 
 
==================================================================================================================================================================
<대안 4. newNode의 next를 nullptr 체크>
- 다시 생각해보자. 이거 먼저 1stCAS한 스레드랑 나중에 CAS한 스레드를 자꾸 1stCAS전에 저장한 tail값이랑 2ndCAS 리턴값으로 어떻게 해보려는데 그냥 각자의 스레드가 newNode를 체크하면 되지
   을까?
   어쨌든 각자의 스레드가 1stCAS를 하면서 tail->next에 본인의 newNode를 저장했을 것임. 나중에 CAS한 스레드는 newNode의 next를 관측했을 때 무조건 nullptr로 보일 수 밖에 없고 먼저 1stCAS를
   통과한 스레드가 newNode->next를 nullptr로 볼 수 있지만 들어간 순간 다른 스레드가 1stCAS를 통과하면서 아닐 수 있음.
- newNode->next가 nullptr이 아닌 경우는 결국 먼저 1stCAS한 스레드가 if문으로 nullptr 체크하기 전에 다른 스레드가 1stCAS 통과해서 노드 붙여버린 경우일 것임. 이때 굳이 먼저 1stCAS한 스레드가
   tail변수를 바꾸거나 할 필요 없이 다른 스레드가 어차피 그때 newNode->next를 nullptr로 체크해서 들어갈것이기 때문에 이때는 그냥 2ndCAS Pass해도 될것 같음.
- 그런데 newNode->next == nullptr일 때도 2ndCAS에서 경쟁이 생길 수 있음. 먼저 1stCAS한 스레드가 if문으로 nullptr체크하고 나서 다른 스레드가 1stCAS해서 붙인다음 if문 안으로 들어가서 2ndCAS에서
   경쟁이 발생하는 경우임. 
===================================================================================================================================================================


2. 대안점 5 제안
- 1번 CAS 성공하고 2번 CAS 실패한 것은 tail이 바뀐 것임. 2ndCAS 실패는 원래 발생할 수 있고 고칠 대상이 아님. 경쟁이 생기거나 하면 실패할 수 있음.
- 락프리라는 것은 결국 내가 하던 행동이 최우선일 것임. 내가 원래 해야 하는일이 아니여도 내 기준으로 조금 손을 댐으로서 내가 일을 더 빨리 처리할 수 있다라면 손을 대자는 것임. 이기적으로 해야 함.
- 결국 스레드 입장에서 이기적으로 하라는 말은 2ndCAS를 실패했을 때 누군가 m_pTail을 다른 값으로 바꿨다는 것이고 그로 인해 내가 실패했으니 그냥 m_pTail을 내가 알던 localTail로 바꿔서 다시
   2ndCAS를 해버리겠다는 것일까?
- 이러면 2ndCAS를 실패하는 상황이 먼저 1stCAS한 스레드가 2ndCAS를 하고 나서 뒤늦게 1stCAS 통과한 스레드가 2ndCAS를 하려고 보니 기존 m_pTail이 노드3(tag:5)이고 localTail이 노드3(tag:0)라서
   2ndCAS를 실패하는데 이때 그냥 m_pTail = localTail하면 m_pTail을 그냥 노드3(tag:0)로 바꿔버리겠다는건데 많이 이상함.

===================================================================================================================================================================

3. 다시 생각


-  지금 착각하고 있는게 2ndCAS 경쟁상태임. 경쟁이 발생할 수 없는 로직임. 아래 2ndCAS를 다시 보면 m_pTail이랑 1stCAS전에 저장한 localTail이랑 비교해서 값을 바꾸는데 이때 먼저 1stCAS한 스레드는 
   m_pTail이랑 localTail이 같을 수 있음. 그런데 뒤늦게 1stCAS한 스레드는 localTail이 결국 재활용한 노드 주소값일 것이고 결국 m_pTail이랑 다름. 먼저 1stCAS한 스레드가 2ndCAS를 하고나서 나중에 CAS한
   스레드가 2ndCAS할 때 지역에 저장한 localTail이 노드 3(tag:0)일 것이고 m_pTail은 노드3(tag:5)일 것이니 그냥 실패함.
   그리고 설령 먼저 1stCAS한 스레드랑 나중에 1stCAS 들어온 스레드랑 동시에 2ndCAS를 하려고 해도 그 당시 m_pTail을 노드 4일 것이고 먼저 1stCAS한 스레드가 저장한 localTail은 노드 4이고 
   나중에 1stCAS한 스레드가 저장한 localTail은 노드3(tag:0)임. 그래서 동시에 들어간다고 해도 나중에 1stCAS한 스레드는 2ndCAS그냥 실패함. 경쟁에서 실패하는게 아님. 그냥 못바꿈. 비교하려는 값이랑
   m_pTail이 애초에 다름.
- 그리고 나중에 1stCAS한 스레드가 먼저 2ndCAS를 수행할 수도 있음. 그런데 이때도 m_pTail은 노드 4이고 localTail이 노드3(tag:0)이니 그냥 애초에 실패하는 것임.
- 먼저 1stCAS한 스레드가 2ndCAS까지 했으면 더 이상 신경 쓸 것없음. 

   InterlockedCompareExchange64((__int64*)&m_pTail, (__int64)newNode, (__int64)localTail);

- 그래서 애초에 if(ret2ndCAS != localTail)에 들어올수 있는 스레드는 나중에 1stCAS한 스레드가 들어올 수 있음.
- 그러면 이때 그냥 m_pTail = newNode로 바꿔서 실제 tail노드 변수에 나중에 1stCAS한 스레드가 붙인 newNode 주소값을 저장해주면 될 듯함.

- 이것만 하면 문제가 없을까? 만약에 나중에 1stCAS한 스레드가 먼저 2ndCAS를 해서 실패하고 m_pTail을 = newNode로 바꿔버리고 먼저 1stCAS한 스레드가 2ndCAS를 진행하는데 이때 m_pTail은
   노드 5이고 localTail은 노드 4이니 if문을 타고 들어 올 수 있음. 그러면 tail변수를 잘못 바꿀 수 있음.
- 그러면 2ndCAS랑 if문으로 실패 체크하는 로직 사이에 2ndCAS의 리턴값이 기존 m_pTail값일텐데 이때 노드 5인 경우를 체크해보면 됨. 즉, return값 tag때서 next가 nullptr인지 체크해보는 것임.
   그래서 nullptr이면 탈출하는 것임.
- 그런데 이때도 생각해봐야 할게 어쨌든 나중에 1stCAS한 스레드가 2ndCAS 실패해서 m_pTail을 자기 노드로 바꾼 순간이때부터 다른 여러 스레드들도 1stCAS를 통과할 수 있게 됨. 
   그래서 먼저 1stCAS한 스레드가 m_pTail이 노드 5로 바뀌고 나서 2ndCAS해서 리턴값을 볼 때 노드 5가 나올 수 있고 이때 next를 체크하기 직전에 다른 스레드가 1stCAS를 통과해서 노드 5의 next에 자기노드를
   붙여버리면 똑같이 if(ret2ndcas != localTail)을 타버릴 것임.
- 그러면 그 노드5의 next에 자기 노드 붙인 스레드가 2ndCAS를 성공하고 나서 실제 큐 맨 뒤 노드로 tail 변수가 이동하고 나서 이 스레드가 2ndCAS할때 ret값을 얻어서 tag때고 next 확인해서 nullptr 체크해야 탈출함.






