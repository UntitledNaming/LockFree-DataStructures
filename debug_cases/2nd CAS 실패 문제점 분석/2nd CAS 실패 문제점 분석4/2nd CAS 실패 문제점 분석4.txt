1. 이전 문제점 개선 방법
- 일단 지금 2nd CAS 경쟁하는 스레드가 2개 이상인 것은 확인 했는데 그 이상이 나올 수 있는지 부터 생각해 보자.
- 우선 1st CAS 전에 tailNode를 저장하고 1st CAS 직전인 스레드는 여러개가 나올 수 있음. 그런데 이때 다른 스레드 1개가 그 tailNode를 Dequeue해서 반납하고 다시 Enqueue해서
   1st CAS 통과해 실제 큐 뒤로 붙인 상태에서 이 여러개의 스레드 중에 어차피 단 1개의 스레드만이 1st CAS를 통과할 수 있음.
- 1st CAS를 통과하고 나면 이제는 본인들이 저장한 tailNode의 next가 결국 그 통과한 스레드의 newNode가 되기 때문에 nullptr이 아니니 1st CAS를 통과할 수 없으니 2nd CAS에서
   경쟁이 발생할 수 있는 스레드는 최대 2개임.

- 그러면 이제 해결 방법을 생각해보자. 지금 문제가 되는 지점이 뒤늦게 1st CAS통과해서 실제 큐의 맨뒤로 노드를 붙인 스레드가 2nd CAS를 성공해서 결과적으로는 tail멤버 변수를
   본인 것으로 바꿔야 함. 2개의 스레드가 경쟁할때 어떤 결과들이 나올지 생각해보자.

   가. 먼저 1st CAS 성공한 스레드가 2nd CAS를 성공하고 뒤이어 들어온 스레드가 2nd CAS 시도 자체를 실패하는 상황

   나. 나중에 1st CAS 성공한 스레드가 2nd CAS를 성공하고 먼저 들어온 스레드가 2nd CAS 를 시도해 실패하는 상황

   다. 먼저 1st CAS 성공한 스레드와 뒤이어 들어온 스레드가 2nd CAS 경쟁해서 먼저 들어온 스레드가 성공하는 상황

   라. 먼저 1st CAS 성공한 스레드와 뒤이어 들어온 스레드가 2nd CAS 경쟁해서 뒤이어 들어온 스레드가 성공하는 상황

- 결론적으로 큐의 상태만을 보자면 먼저 들어온 스레드가 2nd CAS를 성공하고 나서 뒤이어 들어온 스레드가 2nd CAS를 실패해서 실제 큐의 맨 뒤 노드 주소를 tail멤버 변수로 못바꾼 경우와
   나중에 들어온 스레드가 2nd CAS를 성공해서 맨 뒤에 노드 주소를 tailNode 주소로 잘 바꾼 경우가 있음.

- 그러면 우선 2nd CAS 리턴값과 지역에 저장한 tail값을 통해 성공, 실패를 구분할 수 있음.

- 이때 2nd CAS를 실패한 경우 나중에 1st CAS 들어간 스레드가 실패하고 먼저 들어간 스레드가 2nd CAS 성공한 상황을 if로 체크해서 그 때는 어쩔 수 없이 내 노드 주소로 tailNode를 바꾸긴 해야 함.

- 그러면 어떻게 if문으로 그 스레드인지 알 방법을 생각해 봐야 함. 2nd CAS 리턴값 만으로는 파악하기 힘듬. 1st CAS 전후로 tailNode를 저장하는 로직을 넣고 먼저 1st CAS 성공한 스레드는
   이 1st CAS 전후로 tailNode 저장한 값이 같을 것임.
- 반대로 뒤이어 1st CAS 통과한 스레드가 1st CAS 전후로 저장한 tailNode 주소값은 다를 것임. 1st CAS 후 저장한 tailNode 주소값이 그 당시 tailNode 주소값일 것이고 1st CAS 전에 저장한
   tailNode 주소값은 어떻게 보면 먼저 1st CAS 성공한 스레드가 실제 큐 뒤에 붙인 노드의 주소값일 것이니 노드 주소값이 1st CAS 전후로 다를 것임.
- 어쨌든 나중에 1st CAS 통과한 스레드가 1st CAS 전후로 저장한 tailNode 주소값이 만약 먼저 1st CAS 성공한 스레드가 2nd CAS까지 했으면 주소값 자체는 같을 수 있어도 tag값이 다를 것임.

- 먼저 1st CAS 성공한 스레드가 2nd CAS 실패할 때 refresh == localTail로 무조건 1st CAS 성공한 스레드가 여기를 통과할 것으로 볼수 있을 까? 만약 나중에 들어온 스레드가 2nd CAS까지 성공하고
   나서 먼저 1st CAS 성공한 스레드가 refreshTail을 저장하고 나서 2nd CAS를 하면 실패할 것이고 이걸 refreshTail == localTail로 비교하면 당연히 통과 못함.
- 우선 먼저 1st CAS 성공한 스레드가 RefreshTail을 저장하고 나서 뒤늦게 1st CAS 성공한 스레드랑 2nd CAS에서 경쟁에서 실패한 경우인데 이때는 어차피 뒤늦게 들어온 스레드가 2nd CAS 성공해서
   실제 큐의 맨 뒤 노드를 tail변수에 잘 저장한 것이니 문제 없음. 그냥 아무런 처리 안해도 됨.


- 그러면 이제 refreshTail != localTail 비교해서 통과한 경우에 대한 처리를 고민해 봐야 함. 이 내부에서 단순히 m_pTail = newNode로 바꿔 버리면 아까 말했다 시피 나중에 들어온 스레드가 2nd CAS를
   실패해서 여기로 들어온거면 상관이 없음. 그런데 먼저 1st CAS 통과한 스레드도 나중에 1st CAS 통과한 스레드가 2nd CAS도 미리하고 나서 Refresh를 저장했으면 여기에 들어올 수 있음.
   그러면 그 상황을 if로 체크해서 그 때는 못하게 해야 함.

- 그러면 그 상황을 어떻게 if문으로 체크할지 생각해보자. 이때 if(refreshTail != localTail) 안으로 들어온 2가지의 경우에서 어떤 차이점이 있는지 생각해보자. 

- 지금 로직이 2nd CAS할 때  InterlockedCompareExchange64((__int64*)&m_pTail, (__int64)newNode, (__int64)refreshTail); 로 하고 있는데 지금 이거 문제가 만약에 1st CAS 뒤늦게 통과한 스레드가
  m_tail 바꾸고 나서 1st CAS 먼저 통과한 스레드가 refreshTail저장해서 2nd CAS를 하려고 하면 이때 성공해 버리니까 문제가 됨. 그래서 마지막 refreshTail이 아니라 localTail로 바꿔야 함.

- 그래서 다시 생각해보자. 지금 상황을 그림으로 그려봤음. 일단 2nd CAS 실패 상황은 당연히 if(ret != localT)로 체크할 것임. 그러면 이 if문에 걸리는 상황이 자세하게 말해보자. 지금
   CAS의 리턴값이 뭐냐면 m_tail의 초기값을 리턴해줌. 
- 만약 먼저 1st CAS 성공한 스레드가 2nd CAS 성공하고 나서 뒤이어 1st CAS 성공한 스레드가 2nd CAS를 하면 실패를 할텐데 이때 리턴값이 그림을 참고하면 노드 3일 것임. 
   반대로 나중에 1st CAS한 스레드가 2nd CAS 성공하고 먼저 1st CAS 성공한 스레드가 2nd CAS 실패할때 이때 리턴값이 그림 참고시 노드 5일 것임.
   마지막으로 둘다 모두 2nd CAS 자체에서 경쟁할 때는 리턴값이 그림을 보면 노드 4가 리턴될 것임.
- 그러면 이 3가지의 경우를 구분해서 후처리를 할지 말지랑 하면 어떻게 해야 할지를 만들어야 함.


- 우선 각각의 경우를 구분하는 방법으로 ret 실패 했을 때 tail노드를 refresh에 저장하는 것을 생각해 보자. 그러면 먼저 1st CAS 통과한 스레드가 2nd CAS를 먼저 했던가 2nd CAS에서 경쟁에 성공했으면
   뒤늦게 들어온 스레드가 2nd CAS를 실패할 것이고 이때 'A'스레드가 tailNode를 저장해보면 그림 보면 노드 3임. 대신 tag가 다름.
   
- 만약 뒤늦게 1st CAS한 스레드가 2nd CAS를 경쟁에 성공하던 뒤늦게 성공한 스레드가 2nd CAS를 먼저 하던 'B' 스레드가 2nd CAS 실패하고 tailNode를 저장하면 노드 5일 것임. 그러면 이때는 굳이
   처리를 따로 할 필요가 없음.

- 그러면 2nd CAS 실패하고 refresh를 저장해서 if문으로 refresh랑 localtail이랑 같은 경우를 생각해보자. 그런데 'A' 스레드 입장에서는 localTail이 노드 3이고 refresh가 tag다른 3이거나
   'B' 스레드 입장에서는 localTail이 노드 4고 refresh가 노드 5임. 어쨌든 같은 경우는 2nd CAS 실패하고 측정해보면 안나올 것임.

- 그러면 이때 그러면 refresh랑 localTail이랑 다른데 tag만 다른 경우랑 아예 다른 경우가 있을 것임. 아예 다른 경우는 'B' 스레드가 local 4로 저장하고 refresh가 5로 저장된 상태일 것이고
  tag만 다른 경우는 'A'스레드가 local을 노드 3 저장하고 'B'스레드가 2nd CAS 성공해서 tag 다른 노드 3을 m_Tail로 만든 것임. 이때 아예 다른 경우는 어차피 tail멤버 변수가 제대로 바뀐 상태일 것이고
  tag만 다른 경우는 우리가 직접 바꿔야 함. 

- 일단 이렇게 돌려보니 문제는 안생김.

- 그런데 위험한 상황 있다함. 시나리오를 생각해보자. 지금 2ndCAS 실패한 스레드가 나중에 1st CAS 들어온 스레드는 이 로직 수행할 때 문제가 안생길 텐데 만약에 1st CAS 먼저 들어온 스레드가
   2nd CAS를 실패했으면 지금 맨 마지막에 노드를 붙인 노드 주소로 tail이 변경되었을 것임. 이 상황이 언제 발생하냐면 2nd CAS 경쟁에서 먼저 1st CAS 성공한 스레드가 졌으면 localTail != retCAS에서 
   local == retCAS니 그냥 통과할 것임. 문제가 되는 상황이 정확히는 나중에 1st CAS한 스레드가 노드 5로 tail을 바꾸고 나서 먼저 1st CAS 통과한 스레드가 2ndCAS할 때 ret = 5가 나오고 local =4가 나오니
   이때 if문 들어갈 것임.

- 이때는 먼저 1st CAS 성공한 스레드가 2nd CAS 실패해도 tail변수를 제대로 바꿨으니 문제는 안생길텐데
   지금 2nd CAS 실패 후 처리 로직 중에 tail을 다시 저장하고 tag때고 1st CAS 전 tail이랑 비교하는데 여기서 문제가 발생할 수도 있을 듯함.

- 만약에 먼저 1st CAS 성공한 스레드가 refresh = m_tail 저장 직전에 cs스위칭이든 뭐든 여기서 기다리고 있고 지금 m_Tail이 잘 바뀐 상태임. 그림 보면 노드 5로 설정되었을 것임. 
  이때 만약에 다른 스레드가 Dequeue를 해서 4번 노드를 반납하고 다시 Enqueue를 진행할 때 실제 5번 노드 뒤에 4번 노드를 1st CAS해서 붙이고 2nd CAS까지 해서 m_tail변수를 바꾸고 나서 
  2nd CAS 실패 로직중에 refresh = m_ tail을 해서 if문으로 tag때고 비교하면 통과해서 InterlockedExchange64((volatile __int64*)&m_pTail, (__int64)newNode); 이 로직을 실행해버리면 
  실제 큐 맨뒤 노드를 tail로 바꾸는게 아니니 잘못될 것임.


- 그러면 이걸 막기 위한 처리를 생각해보자. 문제 상황에서 ret은 tag달린 노드 5일 것이고 local은 tag달린 노드 4일 것임. 이때 tag값이랑 노드 주소값이랑 아예 다른 경우는 따로 처리 안하게 
   pass해야 할 듯함.

- 2nd CAS값 나오는 것과 그때의 locaTail이 어떤 값이 나올수 있는지 생각해보자. 먼저 1stCAS 성공한 스레드가 2nd CAS까지 해버린 경우 나중에 1st CAS한 스레드가 local에 저장한 값은 노드 3인데
   tag가 0인 주소값일 것이고 ret값은 노드 3인데 tag가 5인 노드값일 수 있음.
- 먼저 1st CAS 성공한 스레드와 나중에 성공한 스레드가 2nd CAS에서 경쟁할 때 먼저 1st CAS성공한 스레드가 실패하면 ret = 노드 4일 것이고 local도 노드 4일 것임. 나중에 성공한 스레드가 실패하면
   ret = 노드 4일 것이고 local은 노드 3일 것임.
- 마지막 경우가 나중에 1stCAS 성공한 스레드가 2nd CAS까지 해버리고 먼저 1st CAS한 스레드가 실패하는 상황임. 이때 실패한 쪽에서 local은 노드 4일 것이고 ret값은 노드 5일 것임.

- 문제가 되는 상황이 나중에 1st CAS한 스레드가 2nd CAS 실패하는 경우 ret값 노드 3에 tag다른 값이고 local도 노드 3인 경우랑, 똑같이 나중에 1st CAS한 스레드가 2ndCAS실패하는데 이때 경합으로
   인해 실패해서 ret값이 노드 4에 local이 노드3인 경우임.
- 먼저 1st CAS한 스레드가 2nd CAS 실패 로직을 타면 안되는 것과 나중에 1st CAS한 스레드가 2nd CAS 실패시 처리 로직하도록 만들어야 함. 애초에 먼저 1st CAS 성공한 스레드가 2nd CAS 실패 로직
  자체를 못타게 하던가 가장 중요한 것은 나중에 1st CAS 성공한 스레드를 어떻게 찾을 지를 생각해야 함.
- 나중에 1st CAS 성공한 스레드를 찾는 방법에서 interlock으로 1st CAS후 어떤 변수 증가시키던가 하는 방법은 애초에 안됨. 원자적이지 않음.


====================================================================================================================================================================
<대안 2. 1st CAS 후 노드 재갱신 해서 2nd CAS하기>

- 일단 1st CAS 통과해서 localTail로 2ndCAS를 진행하는데 그 이후에 tail노드를 2ndCAS 실패 처리하기 전에 tail노드를 재갱신 저장하고 next가 nullptr이면 실패처리 안하고 그냥 break로 나가는 것

//성공하면 tail도 원자적으로 변경
ret2ndCAS = InterlockedCompareExchange64((__int64*)&m_pTail, (__int64)newNode, (__int64)localTail);

//tail노드 재갱신
refreshTail = m_pTail;
RealrefreshTail = (Node*)((uint64_t)refreshTail & BITMASK);
if (RealrefreshTail->_next == nullptr)
    break;


====================================================================================================================================================================

<대안 3. 1st CAS 후 노드 재갱신 작업 부터 2nd CAS까지 다시 do while로 하기>

newNode = (Node*)((UINT64)newNode | (retCnt << 47));

do
{
	refreshTail = m_pTail;
	RealrefreshTail = (Node*)((uint64_t)refreshTail & BITMASK);
	if (RealrefreshTail->_next == nullptr)
	    break;

} while (InterlockedCompareExchange64((__int64*)&m_pTail, newNode, refreshTail));

- 이 구조는 일단 2개 스레드가 tail노드를 갱신하고 각자가 tail멤버변수랑 내가 지역에 저장한 tail이랑 같으면 내 노드로 tail노드 바꾸도록 하는 것임.
- 이런 구조에서 여러가지 상황을 생각해보자. 먼저 1st CAS한 스레드가 2nd CAS까지 해도 어차피 그 리턴값이 nullptr이 아니기 때문에 루프를 한번 더 도는데 이때 다시 m_tail을 저장해서
   그것의 next가 nullptr이면 즉, 진짜 m_tail이 큐의 끝이면 탈출할 것임. 이때 나중에 1st CAS한 스레드가 영향주는게 없는 상황임
- 그러면 반대로 나중에 1st CAS한 스레드가 2nd CAS를 해서 tail변수를 바꾸고 나서 다음 루프에 와서 tail재갱신하고 next확인해서 탈출할 것임. 
- 만약에 동시에 재갱신하고 2nd CAS를 해서 먼저 1st CAS 성공한 스레드가 실패하고 나중에 온 스레드가 성공하면 tail은 제대로 갱신된 상태일 것임. 그래서 다음 루프에서 각자가 tail 재갱신해서
  next를 확인하면 nullptr일 것임.
- 반대로 나중에 1st CAS 성공한 스레드가 실패하고 먼저 1st CAS 성공한 스레드가 2nd CAS를 경합에 성공한다면 다음 루프에서 어차피 tail 재갱신하고 next보면 nullptr이 아닐 것임. 그래서 탈출 못하고
   나중에 1st CAS 성공한 스레드도 다음 루프에서 tail 재갱신해봐야 탈출 못하지만 이때 다시 한번 재갱신한 tail노드와 m_tail 비교해서 나중에 1st CAS한 스레드가 성공한 순간 먼저 1st CAS한 스레드던
   나중에 1st CAS 성공한 스레드던 다음 루프에서 tail 갱신하고 next가 nullptr인지 체크할 때 탈출할 수 있음.

- 결국 실제로 큐 맨 뒤에 newNode를 붙인 스레드가 2ndCAS를 통해 m_Tail까지 바꾸면 탈출 가능성이 생길 수 있음. 다만 이때 2개 제외하고 다른 스레드들도 Enqueue가 가능해진 상태라서 만약 그 스레드들이
  1st CAS를 통과해 버리면 기존 2개의 스레드들이 if문에서 next == nullptr를 통과못하고 그 1st CAS 성공한 스레드가 2nd CAS 성공해서 m_tail을 자기 노드로 바꿀 때까지 루프 돌아야 함. 
- 그래서 진짜 타이밍 안맞으면 tail 갱신 저장하려는데 자꾸 1st CAS를 해버려서 루프를 계속 도는 상황이 나올 수 있을 듯함.
- 그리고 돌리고 나서 Dequeue를 하는지 중단점 걸어 보는데 지금 무한 루프를 돌고 있음.


====================================================================================================================================================================


